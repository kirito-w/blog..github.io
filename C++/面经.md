## 1、new/delete 和 malloc/free 区别
- 相同点：
    - 都用于`内存的动态申请和释放`
- 不同点：
    - 1、new/delete是`C++运算符`，malloc/free是`C/C++标准库函数`(需要库文件支持)
    - 2、new`自动计算`要分配的空间大小，malloc需要`手动指定`要分配的空间大小
    - 3、new/delete返回`具体类型指针`，malloc/free返回`void类型指针`
    - 4、new是`类型安全`(**如果类型不同，编译时会报错**)的，malloc不是
    - 5、new/delete会执行`构造函数/析构函数`，malloc/free不会
    - 6、`new内存分配失败`时，会`抛出bac_alloc异常`。`malloc分配内存失败`时`返回NULL`。

## 2、什么是类型安全？
- "类型安全"常被用来形容编程语言，其根据在于该门编程语言`是否提供保障类型安全的机制`;
- 有的时候也用"类型安全"形容某个程序，`判别的标准`在于该程序`是否隐含类型错误`。

## 3、指针和引用的区别
- 1）`指针`是一个变量，`存储的是一个地址`；引用`和原来的变量`本质上`是一个东西`，是`原变量的别名`
- 2）`指针可以为空`，`引用不能为NULL`且在`定义时必须初始化`
- 3）`指针`在`初始化后可以改变指向`，而`引用`在`初始化之后不可再改变`
- 4）`sizeof指针`得到的是`本指针的大小`，`sizeof引用`得到的是`引用所指向变量的大小`
- 5）`不存在指向空值的引用`，必须有具体实体; 但是`存在指向空值的指针`

## 4、static关键字作用
- 不考虑类的情况：
    - 1、`隐藏`。所有不加static的全局变量和函数具有全局可见性，可以在其他文件中使用，加了之后只能在该文件所在的编译模块中使用
    - 2、`默认初始化为0`，包括未初始化的全局静态变量与局部静态变量，都存在全局未初始化区
    - 3、静态变量`在函数内定义`，`始终存在，且只进行一次初始化，具有记忆性`，其`作用范围与局部变量相同`，`函数退出后仍然存在，但不能使用`
- 考虑类的情况：
    - 1、static成员变量:只`与类关联`，不与对象关联。定义时要分配空间，不能在类声明中初始化，必须在类定义体外部初始化，初始化时不需要标示为static;可以被非static成员函数任意访问
    - 2、static成员函数:`不具有this指针`，`无法访问`类对象的`非static成员变量和非static成员函数`;`可以被非static成员函数任意访问`

## 5、静态成员(static)与普通成员的区别是什么
- 1.生命周期
    - 静态成员变量`从类被加载开始到类被卸载，一直存在`;
    - 普通成员变量只有`在类创建对象后才开始存在`，`对象结束`，它的`生命期结束`;
- 2.共享方式
    - 静态成员变量是`全类共享`;普通成员变量是`每个对象单独享用`的;
- 3.定义位置
    - 普通成员变量存储在`栈或堆中`，而静态成员变量存储在`静态全局区`
- 4.初始化位置
    - 普通成员变量`在类中初始化`;静态成员变量`在类外初始化`;
- 5.默认实参
    - 可以使用静态成员变量作为默认实参    

## 6、内联函数和宏定义区别
- 在使用时，`宏`只做`简单字符串替换(编译前)`。而`内联函数`可以`进行参数类型检查(编译时)`，且`具有返回值`。
- `内联函数`在`编译时`直接`将函数代码嵌入到目标代码`中，`省去函数调用的开销`来`提高执行效率`，并且`进行参数类型检查`，具有返回值，`可以`实现`重载`。
- 宏定义时要注意书写(参数要括起来)否则容易出现歧义，内联函数不会产生歧义
- `内联函数`有`类型检测、语法判断`等功能，而`宏没有`
### 内联函数适用场景:
- 使用宏定义的地方都可以使用 inline 函数。
- 作为`类成员接口函数`来`读写类的私有成员或者保护成员`，会提高效率。

## 7、内存泄露
- 一般我们常说的内存泄漏是指`堆内存的泄漏`。
- 堆内存是指程序从堆中分配的，大小任意的(内存块的大小可以在程序运行期决定)内存块，`使用完`后`必须显式释放`的内存。应用程序般使用malloc、realloc、new等函数从堆中分配到块内存，`使用完后，程序必须负责相应的调用free或delete释放该内存块，否则，这块内存就不能被再次使用，我们就说这块内存泄漏了`
### 避免内存泄露的几种方式
- 计数法:使用new或者maloc时，让该数+1，delete或free时，该数-1，程序执行完打印这个计数，如果不为0则表示存在内存泄露
- 一定要将`基类`的`析构函数`声明为`虚函数`
- `对象数组`的释放一定要用`delete []`
- 有new就有delete，有malloc就有free，`保证它们一定成对出现`

## 8、数组和指针的区别
- 1.`数组`在`内存中`是`连续存放`的，开辟`一块连续的内存空间`;数组所占存储空间:sizeof(数组名);数组大小:sizeof(数组名)/sizeof(数组元素数据类型);
- 2.用运算符sizeof 可以计算出数组的容量(字节数)。sizeof(p),`p为指针`得到的是`一个指针变量的字节数`，而不是p所指的内存容量。
- 3.编译器为了简化对数组的支持，实际上是利用指针实现了对数组的支持。具体来说，就是`将表达式中的数组元素引用转换为指针加偏移量的引用`。
- 4.在向函数传递参数的时候，如果实参是一个数组，那用于接受的形参为对应的指针。也就是`传递过去是数组的首地址`而不是整个数组，能够提高效率;
- 5.在使用下标的时候，两者的用法相同，都是原地址加上下标值，不过`数组的原地址`就是`数组首元素的地址`，`是固定的`;指针的原地址就不是固定的。

## 9、你知道回调函数吗？它的作用？
- 1.当发生某种事件时，系统或其他函数将会自动调用你定义的一段函数;
- 2.回调函数就`相当于一个中断处理函数`，由`系统在符合你设定的条件`时`自动调用`。为此，你需要做三件事:`①声明;②定义;③设置触发条件。`就是`在你的函数中`把你的`回调函数名称转化为地址`作为一个`参数`，以`便于系统调用`;
- 3.回调函数就是一个`通过函数指针调用的函数`。如果你把函数的指针(地址)作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数;
- 4.因为可以把调用者与被调用者分开。`调用者不关心谁是被调用者`，所有它需知道的，`只是存在一个具有某种特定原型、某些限制条件(如返回值为int)的被调用函数`。

## 10、C++从代码到可执行程序经历了什么？
- 1、预编译
    - 宏展开，头文件展开，条件预编译指令处理(ifdef)
- 2、编译
    - 把预编译之后生成的`xxx.i文件`，进行一系列`词法分析、语法分析、语义分析`及`优化`后，生成相应的`汇编代码文件`。
- 3、汇编
    - `将汇编代码转变成机器可以执行的指令(机器码文件xxx.s)`。 
    - 汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表-一翻译过 来，汇编过程有汇编器as完成。
    - 经`汇编之后`，`产生目标文件`(与可执行文件格式几乎一样)`xxx.o`(Linux 下)。
- 4、链接
    - 将`不同的源文件产生的目标文件进行链接`，从而`形成一个可以执行的程序`。

## 11、析构函数的作用，如何起作用？
- 1.`构造函数只是起初始化值的作用`，但实例化一个对象的时候，可以通过实例去传递参数，从主函数传递到其他的函数里面，这样就使其他的函数里面有值了。只要你`一实例化对象`，系统`自动调用`一个`构造函数`, 就是你不写，编译器也自动调用一次。
- 2.`析构函数与构造函数的作用相反`，用于`撤销对象的一些特殊任务处理`，可以是`释放对象分配的内存空间`。特点:`析构函数与构造函数同名`，但该`函数前面加~`。`析构函数没有参数`，也`没有返回值`，而且`不能重载`，在`一个类中只能有一个析构函数`。`撤销对象时`，编译器也会`自动调用析构函数`。
- 3.每一个类`必须有一个析构函数`，用户`可以自定义析构函数`，也可以是`编译器自动生成默认的析构函数`。`一般`析构函数定义为类的`公有成员`。

## 12、构造函数能否声明为虚函数或者纯虚函数，析构函数呢？
- 析构函数:
    - **析构函数可以为虚函数**，并且`一般情况下基类析构函数要定义为虚函数`。
    - 只有`在基类析构函数定义为虚函数`时，调用操作符`delete销毁指向对象的基类指针`时，`才能准确调用派生类的析构函数(从该级向上按序调用虚函数)`，才能准确销毁数据。
    - `析构函数可以是纯虚函数`，含有纯虚函数的类是抽象类，此时不能被实例化。但派生类中可以根据自身需求重新改写基类中的纯虚函数。
- 构造函数:
    - `虚函数对应一个vtable(虚函数表)`，`类中`存储一个`vptr指向这个vtable`，`这个vptr在对象实例化后才存在`。
    - 如果构造函数`是虚函数`，就`需要通过vtable调用`，可是此时`对象没有实例化`，`就没有vptr`，`无法找到vtable`，所以**构造函数不能是虚函数**。


## 13、虚析构函数的作用，父类的析构函数是否要设置为虚函数
- 1.C++中`基类采用virtual虛析构函数`是为了`防止内存泄漏`。
    - 具体地说，`如果派生类中申请了内存空间`，并`在其析构函数中`对这些`内存空间进行释放`。假设基类中采用的是非虚析构函数，当`删除基类指针指向的派生类对象时`就`不会触发动态绑定`，因而`只会调用基类的析构函数`，而`不会调用派生类的析构函数`。
    - 那么在这种情况下，`派生类中申请的空间就得不到释放从而产生内存泄漏`。所以，为了防止这种情况的发生，C++中基类的析构函数应采用virtual虚析构函数。
- 2.`纯虚析构函数一定得定义`，因为每一个派生类析构函数会被编译器加以扩张，以静态调用的方式调用其每一个虚基类以及上一层基类的析构函数。因此，缺乏任何一个基类析构函数的定义，就会导致链接失败，`最好不要把虚析构函数定义为纯虚析构函数`。

## 14、类什么时候会析构
- 1.`对象`生命周期结束，`被销毁`时;
- 2.`delete指向对象的指针`时，或`delete指向对象的基类类型指针，而其基类虚构函数是虚函数`时;
- 3.`对象i是对象o的成员`，o的析构函数被调用时，对象i的析构函数也被调用。

## 15、可以说一下你了解的C++得内存管理吗？
- ①`栈`，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，`效率很高`，但是`分配的内存容量有限`。
- ②`堆`，就是那些由`new分配的内存块`，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。`如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收`。
- ③`全局/静态存储区`，内存`在程序编译的时候`就`已经分配好`，这块内存`在程序的整个运行期间都存在`。它主要`存放静态数据`(局部static变量，全局static变量)、`全局变量和常量`。
- ④`常量存储区`，这是一块比较特殊的存储区，他们里面`存放的是常量字符串，不允许修改`。
- ⑤`代码区`，`存放程序的二进制代码`

## 16、关于this指针你知道什么？全说出来
- 1、this指针`是类的指针`，`指向对象的首地址`。
- 2、this指针`只能在成员函数中使用`，在全局函数、静态成员函数中都不能用this。
- 3、this指针`只有在成员函数中才有定义`，且存储位置会因编译器不同有不同存储位置。

## 17、如果有一个空类，它会默认添加哪些函数
- 1、Empty();// 缺省构造函数//
- 2、Empty( const Empty&);// 拷贝构造函数//
- 3、~Empty();//析构函数//
- 4、Empty& operator=( const Empty&);// 赋值运算符//

## 18、C++的多态如何实现
- C++的多态性，一言以蔽之就是:
    - 在`基类的函数前加上virtual关键字`，在`派生类中重写该函数`，`运行时`将会`根据所指对象的实际类型`来`调用相应的函数`，如果`对象类型是派生类`，就`调用派生类的函数`，如果`对象类型是基类`，就`调用基类的函数`。

## 19、介绍面向对象的三大特性，并且举例说明
- 三大特性:`继承、封装和多态`
- (1)继承
    - 让某种类型对象获得另一个类型对象的属性和方法。
    - 它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展
    - 常见的继承有三种方式:
        - 1.实现继承:指使用基类的属性和方法而无需额外编码的能力
        - 2.接口继承:指仅使用属性和方法的名称、但是子类必须提供实现的能力
        - 3.可视继承:指子窗体(类)使用基窗体(类)的外观和实现代码的能力(C++里好像不怎么用)
    - 例如，将人定义为一个抽象类，拥有姓名、性别、年龄等公共属性，吃饭、睡觉、走路等公共方法，在定义一个具体的人时，就可以继承这个抽象类，既保留了公共属性和方法，也可以在此基础上扩展跳舞、唱歌等特有方法
- (2)封装
    - 数据和代码捆绑在一起，避免外界干扰和不确定性访问。
    - 封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏，例如:将公共的数据或方法使用public修饰，而不希望被访问的数据或方法采用private修饰。
- (3)多态
    - `同一事物表现出不同事物的能力`，即`向不同对象发送同一消息`，`不同的对象在接收时会产生不同的行为`(`重载`实现`编译时多态`，`虚函数`实现`运行时多态`)。
    - 多态性是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单一句话:允许将子类类型的指针赋值给父类类型的指针
    - 实现多态有二种方式:`覆盖(override)`，`重载(overload)`。
        - 覆盖（`运行时多态`）:是指子类重新定义父类的虚函数的做法
        - 重载（`编译时堕胎`）:是指允许存在多个同名函数，而这些函数的参数表不同(或许参数个数不同，或许参数类型不同，或许两者都不同)。例如:基类是一个抽象对象——人，那教师、运动员也是人，而使用这个抽象对象既可以表示教师、也可以表示运动员。
