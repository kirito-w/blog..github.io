# Linux 常见 I/O模型
## I/O的概念：
- IO (Input/Output，输入/输出)即`数据的读取（接收）或写入（发送）`操作，通常`用户进程中的一个完整IO`分为两阶段：`用户进程空间<-->内核空间、内核空间<-->设备空间（磁盘、网络等）`。IO有内存IO、网络IO和磁盘IO三种，通常我们说的IO指的是后两者。
- LINUX中`进程无法直接操作I/O设备`，其必须通过`系统调用`请求`kernel来协助`完成I/O动作；内核会`为每个I/O设备维护一个缓冲区`。
- 对于一个输入操作来说，进程IO系统调用后，内核会`先看缓冲区中有没有相应的缓存数据`，没有的话再到设备中读取，因为`设备IO一般速度较慢，需要等待`；内核缓冲区有数据则直接复制到进程空间。

## 常见的5种I/O模型
### 1、阻塞IO模型（不持续占用CPU）
- 最传统的一种IO模型，即`在读写数据过程中会发生阻塞现象`。  
- 当用户线程`发出IO请求`之后，内核会去`查看缓冲区是否就绪`，如果`没有就绪`就会`等待数据就绪`，而用户线程就会处于阻塞状态，`用户线程交出CPU`。当数据就绪之后，内核会`将数据拷贝到用户线程`，并返回结果给用户线程，`用户线程`才`解除block`状态。  
![](img/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_17199199285206.png)
- `不适用并发量大`的应用：因为`一个请求IO会阻塞进程`，所以，得`为每个请求分配`一个`处理进程（线程）`以及时响应，`系统开销大`。
### 2、非阻塞IO模型（持续占用CPU）
- 当用户线程`发起一个IO操作`后，并`不需要等待`，而是`马上`就得到了一个`结果`。如果`结果`是一个`error`时，它就知道`数据还没有准备好`，于是它可以`再次发送IO操作`。一旦内核中的`数据准备好`了，`并且又再次收到`了用户线程的请求，那么它马上就`将数据拷贝到了用户线程`，然后返回。  
![](img/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_17199199392124.png)
- 在非阻塞IO模型中，用户线程`需要不断地询问`内核数据是否就绪，也就说`非阻塞IO不会交出CPU`，而会`一直占用CPU`。
- 这种`对一个非阻塞IO端口反复调用read`进行数据读取的动作`称为轮询`
- `对于非阻塞IO就有一个非常严重的问题，在while循环中需要不断地去询问内核数据是否就绪，这样会导致CPU占用率非常高，因此一般情况下很少使用while循环这种方式来读取数据。`
### 3、IO复用模型（带端口监控的无阻塞IO） —— `生产中经常会用到的一种模型`
- `非阻塞IO模型的问题`在于，尽管应用程序可以在`当前IO操作不能完成`的时候迫使`系统调用立刻返回`而`不至于睡眠`，但是却`无法知道什么时候再次请求IO操作可以顺利完成`，只能周期性地`做很多无谓的轮询`,极大浪费了CPU资源。
- IO多路复用模型就是`在此之上的改进`，它的好处在于使得`应用程序`可以`同时对多个IO端口进行监控`以`判断`其上的操作`是否可以顺利（无阻塞地）完成`，`达到时间复用`的目的。
- `进程阻塞在类似于select、poll或epoll这样的系统调用`上，而`不是阻塞在真正的IO系统调用`上，意思也就是说在这些select、poll或者epoll函数内部会`代替我们做非阻塞地轮询`  
![](img/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_17199214941052.png)
- IO多路复用模型主要有3种实现形式，select、poll、epoll。
- select也叫复用器
### 4、信号驱动IO模型
- 实时信号驱动(rtsig)IO模型使得应用程序`不需要阻塞在某一个或多个IO端口`上，它先利用`系统调用sigaction`来`安装某个端口的事件信号处理函数`，该系统`调用sigaction执行成功后立即返回`，`进程继续往下工作`而不被阻塞，当`某个IO端口上可进行数据操作`时，内核就`为该进程产生一个SIGIO信号`，进程`收到该信号`后相应地`在信号处理函数里进行IO`操作，因此，这种机制使得程序能够`在一个更合适的时间点`被通知到，被通知`去执行IO事件`处理.  
![](img/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_17199218467729.png)
- 之所以说是通知的时间点更好，是因为`此时进行IO需要的数据已就绪`，IO处理`可以保证无阻塞地完成`。
- 实时信号驱动IO`完全不是在select/poll基础上的修改`，而是`对传统信号驱动IO的完善`，因此它是完全不同于前面介绍的几种解决方案的事件驱动IO机制。

### 小结
- 阻塞IO模型、非阻塞IO模型、IO复用模型和信号驱动IO模型都是`同步的IO模型`。原因是因为，无论以上哪种模型，真正的`数据拷贝过程`，都是`同步进行`的。
- 我们把钓鱼过程，可以拆分为两个步骤：1、鱼咬钩（数据准备）。2、把鱼钓起来放进鱼篓里（数据拷贝）。无论以上提到的哪种钓鱼方式，在第二步，都是`需要人主动去做的，并不是鱼竿自己完成`的。所以，这个钓鱼过程其实还是同步进行的。
-------------------------------------------------

### 5、异步IO模型
- 异步IO也是属于POSIX规范的一部分，`类似实时信号驱动IO的异步通知机制`，这也使得异步IO模型常常与后者相混淆。
- 与后者的区别在于，启用异步IO意味着`告知内核启动某个IO操作`，并让内核在`整个操作（包括将数据从内核复制到用户空间的缓冲区）完成`时通知我们。
- 也就是说，`实时信号驱动IO`是由内核通知我们`何时可以启动`一个IO操作，而在`异步IO模型`中，是由内核通知我们IO操作`何时完成`，即实际的IO操作是异步的。  
![](img/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_17199222055368.png)

## 5个IO模型比较：
![](img/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_17199225468127.png)


# 相关文档
- https://blog.csdn.net/gui951753/article/details/82348485
- https://cloud.tencent.com/developer/article/1684951
- https://www.cnblogs.com/schips/p/12543650.html
- https://www.hitzhangjie.pro/blog/2017-05-02-linux-common-io-model/
