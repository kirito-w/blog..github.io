# Linux驱动学习
## Linux内核
### 定义
- Linux内核是 Linux `操作系统`（OS）的`主要组件`，也是计算机`硬件与其进程`之间的`核心接口`。它`负责两者之间的通信`，还要`尽可能高效地管理资源`。
- 之所以称为内核，是因为在操作系统中就像果实硬壳中的种子一样，`控制着硬件`（无论是电话、笔记本电脑、服务器，还是任何其他类型的计算机）的`所有主要功能`。
### Linux 内核的作用是什么？
- 内核有以下四项作用：
    - 1、`内存管理`：追踪记录有多少内存存储了什么以及存储在哪里
    - 2、`进程管理`：确定哪些进程可以使用中央处理器（CPU）、何时使用以及持续多长时间
    - 3、`设备驱动程序`：充当`硬件与进程之间`的调解程序/解释程序
    - 4、`系统调用和安全防护`：从流程接受服务请求

### 在正确实施的情况下，`内核对于用户是不可见的`，它在自己的小世界（称为内核空间）中工作，并从中分配内存和跟踪所有内容的存储位置。
### 用户所看到的内容（例如 Web 浏览器和文件）则被称为`用户空间`。这些`应用通过系统调用接口`（SCI）`与内核进行交互`。
### 内核在操作系统中的位置
- 为了更具象地理解内核，不妨将 Linux 计算机想象成有`三层结构`：
    - 1、`硬件`：物理机（这是系统的底层结构或基础）是由内存（RAM）、处理器（或 CPU）以及输入/输出（I/O）设备（例如存储、网络和图形）组成的。其中，CPU 负责执行计算和内存的读写操作。
    - 2、`Linux 内核`：操作系统的`核心`。（没错，内核正处于核心的位置）它是驻留在内存中的软件，用于告诉 CPU 要执行哪些操作。
    - 3、`用户进程`：这些是`内核所管理的运行程序`。用户进程共同构成了用户空间。用户进程有时也简称为进程。内核还`允许这些进程和服务器彼此进行通信`（称为进程间通信或 IPC）。
- 系统执行的代码通过以下`两种模式之一`在 CPU 上运行：`内核模式或用户模式`。
    - 在`内核模式`下`运行的代码`可以`不受限制地访问硬件`，
    - 而`用户模式`则会`限制 SCI 对 CPU 和内存的访问`。内存也存在类似的分隔情况（内核空间和用户空间）。
    - 这两个小细节构成了一些复杂操作的基础，例如`安全防护`、`构建容器`和`虚拟机`的权限分隔。
- 这也意味着：
    - 如果`进程在用户模式下失败`，则损失有限，无伤大雅，`可以由内核进行修复`。
    - 另一方面，由于`内核进程要访问内存和处理器`，因此`内核进程的崩溃`可能`会引起整个系统的崩溃`。
    - 由于`用户进程之间会有适当的保护措施和权限要求`，因此`一个进程的崩溃通常不会引起太多问题`。

### Linux内核的任务：
- 1.从`技术层面`讲，内核是`硬件与软件之间`的一个`中间层`。作用是`将应用层序的请求传递给硬件`，并充当底层驱动程序，对系统中的各种设备和组件进行寻址。
- 2.从`应用程序的层面`讲，`应用程序`与硬件没有联系，`只与内核有联系`，`内核是应用程序知道的层次中的最底层`。在实际工作中内核抽象了相关细节。
- 3.内核是一个`资源管理程序`。负责将可用的共享资源(CPU时间、磁盘空间、网络连接等)分配得到`各个系统进程`。
- 4.内核就`像一个库`，`提供`了一组`面向系统的命令`。`使得系统调用对于应用程序来说，就像调用普通函数一样`。

### 内核实现策略：
- 1.`微内核`。`最基本的功能`由中央内核（微内核）实现。所有其他的功能都委托给一些独立进程，这些进程通过明确定义的通信接口与中心内核通信。
- 2.`宏内核`。内核的所有代码，包括子系统（如内存管理、文件管理、设备驱动程序）都打包到一个文件中。内核中的每一个函数都可以访问到内核中所有其他部分。目前支持模块的动态装卸(裁剪)。Linux内核就是基于这个策略实现的。

===============================================================================================================================================================================

## 异常和中断
- `异常（Exception）`：异常是由于程序执行错误、硬件故障或其他问题而引起的事件。在异常发生时，操作系统会暂停当前进程的执行并进行相应处理。常见的异常包括`页面错误（Page Fault）、除零错误（Divide-by-Zero Error）、非法指令（Illegal Instruction）`等。`操作系统`通常会`根据异常类型`执行相应的`异常处理程序`，例如`关闭进程或显示错误消息`。

- `中断（Interrupt）`：中断是由硬件设备发出的信号，用于通知操作系统发生了一个事件，例如按下键盘键、I/O设备准备好或定时器到期。当中断发生时，操作系统会暂停当前进程的执行，并将控制转移到中断处理程序（Interrupt Handler），处理与中断相关的操作，例如读取键盘输入或从设备读取数据。

### 中断的分类
- 中断可分为`硬件中断和软件中断`（也称为`陷阱`或`系统调用`）
- 这种机制`允许操作系统`在`需要时立即响应硬件设备的事件或程序对操作系统的请求`。
- 中断的`持续时间通常很短`，它的`目的是尽快响应某个事件或请求`。
- 中断处理程序会尽量快速地完成所需操作，并`尽早将控制权返回给被中断的进程`。
#### 硬件中断(`陷阱`)
- 由`外部硬件设备`触发
- 实例：
```
1、键盘中断：按下键盘上的任意键时，硬件会产生一个中断信号，操作系统可以通过键盘中断处理程序获取按键信息。
2、鼠标中断：鼠标移动或点击时，鼠标硬件会触发一个中断信号，操作系统可以通过鼠标中断处理程序获取鼠标位置和操作信息。
3、定时器中断：定时器硬件会定期产生一个中断信号，操作系统可以利用定时器中断来进行调度、维护时间等。
```

#### 软件中断(`系统调用`)
- 由`程序中的特殊指令`触发
- 实例：
```
1、文件操作：进程需要打开、读取或写入文件时，可以通过软件中断触发相应系统调用，操作系统会处理相关的文件操作。
2、网络通信：进程需要进行网络通信时，例如发送或接收数据，可以通过软件中断请求相应的网络操作，操作系统会处理网络数据传输。
3、进程控制：进程需要创建、中止或等待其他进程时，可以通过软件中断请求进行相应的进程控制操作，操作系统会管理进程的状态和调度。
```

===============================================================================================================================================================================
## GPIO
- GPIO是指"General Purpose Input/Output"（通用输入/输出）接口，它是一种用于处理外部设备与计算机或微控制器之间通信的通用接口标准。`GPIO接口可用于连接和控制各种硬件设备`，如传感器、执行器、开关、LED等。
- 通过GPIO接口，计算机或微控制器可以向外部设备发送数字信号（输出），也可以接收来自外部设备的数字信号（输入），因此它具有输入和输出的双重功能。`通过设置GPIO引脚的电平状态`（高电平或低电平），可以控制外设的操作或读取外设的状态。
- 在计算机领域，GPIO常用于单片机、嵌入式系统和物联网设备中，以实现与外部设备的通信和控制。`例如，它可以用来控制LED的开关、读取传感器数据、控制电机等。`

================================================================================================================================================================================

## 驱动
### `机制`和`策略`的区分是其中一个在Unix设计背后的最好观念。大部分的编程问题其实可以划分为2部分：“`提供什么能力`”(机制)和“`如何使用这些能力`”(策略)。
### `驱动程序的角色是提供机制，而不是策略`
### Linux驱动分为`字符设备`驱动、`块设备`驱动、`网络设备`驱动。
- 字符设备驱动:
    - 字符设备是能够像`字节流`（比如文件）一样被访问的设备，就是说`对它的读写是以字节为单位`的。
    - 是`必须以串行顺序依次访问`的设备。
    - 字符设备的驱动程序中实现了`open、close、read、write` 等系统调用。
    - 如`led、触摸屏、鼠标`等。
- 块设备驱动
    - 块设备可以`按任意顺序访问`，`以块为单位`进行操作
    - 比如 NAND FLASH上的数据就是以页为单位存放的。
    - 块设备驱动程序向用户层提供的接口与字符设备一样， `应用程序`也可以`通过相应的设备文件`(比如`/dev/mtdblock0、/dev/hda1` 等)来`调用 open、close、read、write 等系统`调用，`与块设备传送任意字节的数据`。
- 网络设备驱动
    - 网络设备是`面向数据包的接收和发送`设计的，在文件系统中`并没有对应的设备结点`，通过`socket接口`进行访问
    - 同时具有字符设备、块设备的部分特点，无法将它归入这两类中：
        - 如果说它是字符设备，他的输入/输出却是`有结构`的、成块的(报文、包、帧)；
        - 如果说它是块设备，它的“块”又`不是固定大小`的，大到数百甚至数千字节，小到几字节。
    - UNIX 式的操作系统`访问网络接口的方法`是给它们`分配一个唯一的名字`(比如 eth0)，但这个名字`在文件系统`中(比如/dev 目录下)`不存在对应的节点项`。

### 在linux系统中，有一个约定俗成的说法`一切皆是文件`。应用程序使用设备文件节点访问对应设备。
- linux下的`各种硬件设备以文件的形式存放`在/dev目录下，通过ls /dev查看。
- linux`把对硬件的操作`全部`抽象成对文件的操作`，比如open、read、write、close等。
### 实例：
- `一个led设备`，在`文件系统中表现为一个设备节点`/dev/led，应用层通过open、read、write等系统调用就可以控制led
- 例如`想让led亮，就打开设备文件写1`
- 现在思考一个问题，为什么这样就可以使led点亮？
    - 要想让led点亮，`必须操作硬件`，`操作硬件`这部分工作就是`led的驱动`所`完成`的
    - 最简单的方式就是，应用层`对led进行open`操作，那么就`对应led驱动程序`中的一个`led_open`。应用层`对led进行write`操作，就对`应led驱动程序的一个led_write`操作，然后`在led_write操作中去操控硬件，进而控制led`
- 那么`对led设备节点`进行open、write系统调用，怎么才能调用到驱动程序的led_open、led_write呢？
    - 当`应用层调用open、read、write`等操作时，会`引发一个异常`，导致`系统变为内核态`，然后再去执`行相应的系统`调用`sys_open、sys_read、sys_write`等
    - 在sys_open、sys_read、sys_write中会去`找到相应的驱动程序`，然后再`调用驱动程序`的open、read、write去`操作硬件`
- 如下图：
![](img/%E5%9B%BE%E7%89%8758.png)

