## TCP三次握手
![](img/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png)
- 开始客户端和服务器都处于CLOSED状态，然后服务端开始监听某个端口，进入LISTEN状态
    - 第一次握手(SYN=1, seq=x)，发送完毕后，客户端进入 SYN_SEND 状态
    - 第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1)， 发送完毕后，服务器端进入 SYN_RCVD 状态。
    - 第三次握手(ACK=1，ACKnum=y+1)，发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时,也进入 ESTABLISHED 状态，TCP 握手，即可以开始数据传输。
    
----------------------------------

## TCP四次挥手  
![](img/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png)
- 第一次挥手(FIN=1，seq=u)，发送完毕后，客户端进入FIN_WAIT_1 状态
- 第二次挥手(ACK=1，ack=u+1,seq =v)，发送完毕后，服务器端进入CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态
- 第三次挥手(FIN=1，ACK1,seq=w,ack=u+1)，发送完毕后，服务器端进入LAST_ACK 状态，等待来自客户端的最后一个ACK。
- 第四次挥手(ACK=1，seq=u+1,ack=w+1)，客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态

----------------------------------

## TIME-WAIT 状态为什么需要等待 2MSL
![](img/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20240822102929.png)
- 2MSL，2 Maximum Segment Lifetime，即两个最大段生命周期
    - 1个 MSL 保证四次挥手中主动关闭方最后的 ACK 报文能最终到达对端
    - 1个 MSL 保证对端没有收到 ACK 那么进行重传的 FIN 报文能够到达

----------------------------------

## TCP报文首部有哪些字段，说说其作用
![](img/TCP%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.png)
- 16位端口号：源端口号，主机该报文段是来自哪里；目标端口号，要传给哪个上层协议或应用程序
- 32位序号：一次TCP通信（从TCP连接建立到断开）过程中某一个传输方向上的字节流的每个字节的编号。
- 32位确认号：用作对另一方发送的tcp报文段的响应。其值是收到的TCP报文段的序号值加1。
- 4位头部长度：表示tcp头部有多少个32bit字（4字节）。因为4位最大能标识15，所以TCP头部最长是60字节。
- 6位标志位：URG(紧急指针是否有效)，ACk（表示确认号是否有效），PSH（缓冲区尚未填满），RST（表示要求对方重新建立连接），SYN（建立连接消息标志接），FIN（表示告知对方本端要关闭连接了）
- 16位窗口大小：是TCP流量控制的一个手段。这里说的窗口，指的是接收通告窗口。它告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。
- 16位校验和：由发送端填充，接收端对TCP报文段执行CRC算法以检验TCP报文段在传输过程中是否损坏。注意，这个校验不仅包括TCP头部，也包括数据部分。这也是TCP可靠传输的一个重要保障。
- 16位紧急指针：一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一字节的序号。因此，确切地说，这个字段是紧急指针相对当前序号的偏移，不妨称之为紧急偏移。TCP的紧急指针是发送端向接收端发送紧急数据的方法。

----------------------------------

## TCP 是如何保证可靠性的
- TCP的连接是基于三次握手，而断开则是四次挥手。`确保连接和断开的可靠性`。
- TCP的可靠性，还体现在`有状态`;TCP会记录哪些数据发送了，哪些数据被接受了，哪些没有被接受，并且保证数据包按序到达，保证数据传输不出差错。
- TCP的可靠性，还体现在`可控制`。它有报文校验、ACK应答、超时重传(发送方)、失序数据重传（接收方）、丢弃重复数据、流量控制（滑动窗口）和拥塞控制等机制。

----------------------------------

## TCP 重传机制
- 超时重传
    - TCP 为了实现可靠传输，实现了重传机制。`最基本的重传机制`，就是超时重传。
    - 即在发送数据报文时，设定一个`定时器`，每间隔一段时间，`没有收到对方的ACK确认应答报文`，就会`重发该报文`。
    - RTT（Round-Trip Time，往返时间）—— 即数据包的一次往返时间
    - RTO —— 超时重传时间(一般1、2、4、8、16成倍数增长)
- 快速重传  
    - 快速重传机制，它`不以时间驱动，而是以数据驱动`。它基于接收端的反馈信息来引发重传。
    - 发送端发送了 1，2，3，4，5,6 份数据:
        - 第一份 Seq=1 先送到了，于是就 Ack 回 2；
        - 第二份 Seq=2 也送到了，假设也正常，于是ACK 回 3；
        - 第三份 Seq=3 由于网络等其他原因，没送到；
        - 第四份 Seq=4 也送到了，但是因为Seq3没收到。所以ACK回3；
        - 后面的 Seq=4,5的也送到了，但是ACK还是回复3，因为Seq=3没收到。
    - 发送端连着收到三个重复冗余ACK=3的确认（实际上是4个，但是前面一个是正常的ACK，后面三个才是重复冗余的），便知道哪个报文段在传输过程中丢失了，于是在定时器过期之前，重传该报文段。
    - 最后，接收到收到了 Seq3，此时因为 Seq=4，5，6都收到了，于是ACK回7.
    - `但快速重传还可能会有个问题：ACK只向发送端告知最大的有序报文段，到底是哪个报文丢失了呢？并不确定！那到底该重传多少个包呢？`
![](img/%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0.png)

- 带选择确认的重传（SACK）  
    - 为了解决快速重传的问题：应该重传多少个包? TCP提供了SACK方法（带选择确认的重传，Selective Acknowledgment）。
    - SACK机制就是，在快速重传的基础上，`接收端返回最近收到的报文段的序列号范围`，这样发送端就知道接收端哪些数据包没收到，酱紫就很清楚该重传哪些数据包啦。SACK标记是加在TCP头部选项字段里面的。
    - 如下图中，发送端收到了三次同样的ACK=30的确认报文，于是就会触发快速重发机制，通过SACK信息发现只有30~39这段数据丢失，于是重发时就只选择了这个30~39的TCP报文段进行重发。  
![](img/%E5%B8%A6%E7%A1%AE%E8%AE%A4%E7%9A%84%E9%87%8D%E4%BC%A0.png)

----------------------------------

## 半连接队列和 SYN Flood 攻击的关系
- TCP进入三次握手前，服务端会从CLOSED状态变为LISTEN状态,同时在内部创建了两个队列：
    - 半连接队列（SYN队列）和全连接队列（ACCEPT队列）。
    - TCP三次握手时，客户端发送SYN到服务端，服务端收到之后，便回复ACK和SYN，状态由LISTEN变为SYN_RCVD，此时这个连接就被推入了SYN队列，即半连接队列。
    - 当客户端回复ACK, 服务端接收后，三次握手就完成了。这时连接会等待被具体的应用取走，在被取走之前，它被推入ACCEPT队列，即全连接队列。

- SYN Flood是一种典型的DoS (Denial of Service，拒绝服务) 攻击，它在短时间内，伪造不存在的IP地址,向服务器大量发起SYN报文。当服务器回复SYN+ACK报文后，不会收到ACK回应报文，导致服务器上建立大量的半连接半连接队列满了，这就无法处理正常的TCP请求啦。

----------------------------------

## TIME_WAIT和CLOSE_WAIT的区别在哪
- CLOSE_WAIT是被动关闭形成的；
    - 当对方close socket而发送FIN报文过来时，回应ACK之后进入CLOSE_WAIT状态。随后检查是否存在未传输数据，如果没有则发起第三次挥手，发送FIN报文给对方，进入LAST_ACK状态并等待对方ACK报文到来
- TIME_WAIT是主动关闭连接方式形成的；
    - 处于FIN_WAIT_2状态时，收到对方FIN报文后进入TIME_WAIT状态；之后再等待两个MSL(Maximum Segment Lifetime:报文最大生存时间)

----------------------------------

## MSS和MTU是什么？
### MTU —— `二层`中的`数据包大小`限制
### MSS —— `TCP协议`中的`最大报文长度`限制
- 最大报文段长度（MSS）与最大传输单元（Maximum Transmission Unit, MTU）均是协议用来定义最大长度的。不同的是，MTU应用于OSI模型的第二层数据链接层，并无具体针对的协议。
- `MTU限制了数据链接层上可以传输的数据包的大小，也因此限制了上层（网络层）的数据包大小`。例如，如果已知某局域网的MTU为1500字节，则在网络层的因特网协议（Internet Protocol, IP）里，最大的数据包大小为1500字节（包含IP协议头）。
- MSS针对的是OSI模型里第四层传输层的TCP协议。因为MSS应用的协议在数据链接层的上层，MSS会受到MTU的限制
-----------------------------------

## TCP的粘包和拆包问题
- 一个完整的包可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送
- 为什么会产生粘包和拆包呢?
    - 要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包；
    - 接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包；
    - 要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包；
    - 待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。即TCP报文长度-TCP头部长度>MSS。

- 程序需要发送的数据大小和TCP报文段能发送MSS（Maximum Segment Size，最大报文长度）是不一样的
    - 大于MSS时，而需要把程序数据拆分为多个TCP报文段，称之为拆包；
    - 小于MSS时，则会考虑合并多个程序数据为一个TCP报文段，则是粘包；
    - 其中MSS = TCP报文段长度-TCP首部长度

- 解决方案：
    - 发送端将每个数据包封装为固定长度
    - 在数据尾部增加特殊字符进行分割
    - 将数据分为两部分，一部分是头部，一部分是内容体；其中头部结构大小固定，且有一个字段声明内容体的大小。

----------------------------------

## 一次HTTP请求，程序一般经历了哪几个步骤
- ：1）解析域名 -> 2）发起TCP三次握手，建立连接 -> 3）基于TCP发起HTTP请求 -> 4）服务器响应HTTP请求，并返回数据 -> 5）客户端解析返回数据

----------------------------------

## SSL/TLS是什么，HTTPS的安全性是怎样实现的？
- SSL(Secure Socket Layer 安全套接层)是基于HTTPS下的一个协议加密层，保障数据私密性。
- TLS(Transport Layer Security)则是升级版的SSL
- https在http基础加了一层安全认证及加密层TLS或者SSL，它首先会通过安全层进行ca证书认证，正确获取服务端的公钥,接着客户端会通过公钥和服务端确认一种加密算法，后面的数据则可以使用该加密算法对数据进行加密


## 相关问题：
https://blog.csdn.net/Rong_Toa/article/details/110773881
https://www.cnblogs.com/kumufengchun/p/14732171.html
https://juejin.cn/post/6983639186146328607
https://interviewguide.cn/notes/03-hunting_job/02-interview/03-04-net.html